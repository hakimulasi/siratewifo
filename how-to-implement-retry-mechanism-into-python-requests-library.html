<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=description content="I would like to add a retry mechanism to Python Requests library, so scripts that are using it will retry for non-fatal errors. At this moment I do consider three kind of errors to be recoverable: At the first stage I do want to retry specified 5xx requests every minute."><meta name=generator content="Hugo 0.98.0"><meta name=robots content="index,follow,noarchive"><title>How to implement retry mechanism into Python Requests library? &#183;</title><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css><!--[if lte IE 8]><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-old-ie-min.css><![endif]--><!--[if gt IE 8]><!--><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css><!--<![endif]--><!--[if lte IE 8]><link rel=stylesheet href=https://assets.cdnweb.info/hugo/blackburn/css/side-menu-old-ie.css><![endif]--><!--[if gt IE 8]><!--><link rel=stylesheet href=https://assets.cdnweb.info/hugo/blackburn/css/side-menu.css><!--<![endif]--><link rel=stylesheet href=https://assets.cdnweb.info/hugo/blackburn/css/blackburn.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css><link rel=preconnect href=https://fonts.gstatic.com><link href="https://fonts.googleapis.com/css2?family=Raleway&display=swap" rel=stylesheet type=text/css><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/styles/androidstudio.min.css><script async src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/highlight.min.js></script>
<script>hljs.initHighlightingOnLoad()</script><link rel="shortcut icon" href=./img/favicon.ico type=image/x-icon></head><body><div id=layout><a href=#menu id=menuLink class=menu-link><span></span></a><div id=menu><a class="pure-menu-heading brand" href=./index.html>SyncVib</a><div class=pure-menu><ul class=pure-menu-list><li class=pure-menu-item><a class=pure-menu-link href=./index.html><i class="fa fa-home fa-fw"></i>Home</a></li><li class=pure-menu-item><a class=pure-menu-link href=./post/index.html><i class="fa fa-list fa-fw"></i>Posts</a></li><li class=pure-menu-item><a class=pure-menu-link href=./sitemap.xml><i class="fa fa-user fa-fw"></i>Sitemap</a></li><li class=pure-menu-item><a class=pure-menu-link href=./index.xml><i class="fa fa-phone fa-fw"></i>RSS</a></li></ul></div><div class="pure-menu social"><ul class=pure-menu-list></ul></div><div><div class=small-print><small>&copy; 2022. All rights reserved.</small></div><div class=small-print><small>Built with&nbsp;<a href=https://gohugo.io/ target=_blank>Hugo</a></small>
<small>Theme&nbsp;<a href=https://github.com/yoshiharuyamashita/blackburn target=_blank>Blackburn</a></small></div></div></div><div id=main><div class=header><h1>How to implement retry mechanism into Python Requests library?</h1><h2>I would like to add a retry mechanism to Python Requests library, so scripts that are using it will retry for non-fatal errors. At this moment I do consider three kind of errors to be recoverable: At the first stage I do want to retry specified 5xx requests every minute.</h2></div><div class=content><div class=post-meta><div><i class="fa fa-calendar fa-fw"></i>
<time>21 Aug 2024, 00:00</time></div></div><img src=https://cdn.statically.io/img/cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto><p>I would like to add a retry mechanism to Python <a href=# rel=noreferrer>Requests</a> library, so scripts that are using it will retry for non-fatal errors.</p><p>At this moment I do consider three kind of errors to be recoverable:</p><ul><li>HTTP return codes 502, 503, 504</li><li>host not found (less important now)</li><li>request timeout</li></ul><p>At the first stage I do want to retry specified 5xx requests every minute.</p><p>I want to be able to add this functionality transparently, without having to manually implement recovery for each HTTP call made from inside these scripts or libraries that are using Python Requests.</p><span class=d-none itemprop=commentCount>5</span><h2 class=mb0 data-answercount=6>6 Answers</h2><p>This snippet of code will make all HTTP requests from the same session retry for a total of 5 times, sleeping between retries with an increasing backoff of 0s, 2s, 4s, 8s, 16s (the first retry is done immediately). It will retry on basic connectivity issues (including DNS lookup failures), and HTTP status codes of 502, 503 and 504.</p><pre><code>import logging import requests from requests.adapters import HTTPAdapter, Retry logging.basicConfig(level=logging.DEBUG) s = requests.Session() retries = Retry(total=5, backoff_factor=1, status_forcelist=[ 502, 503, 504 ]) s.mount('http://', HTTPAdapter(max_retries=retries)) s.get("http://httpstat.us/503") </code></pre><p>See <a href=# rel=noreferrer>Retry class</a> for details.</p><span class=d-none itemprop=commentCount>11</span><p>This is a snippet of code I used to retry for the petitions made with urllib2. Maybe you could use it for your purposes:</p><pre><code>retries = 1 success = False while not success: try: response = urllib2.urlopen(request) success = True except Exception as e: wait = retries * 30; print 'Error! Waiting %s secs and re-trying...' % wait sys.stdout.flush() time.sleep(wait) retries += 1 </code></pre><p>The waiting time grows incrementally to avoid be banned from server.</p><span class=d-none itemprop=commentCount>2</span><p>Possible solution using <a href=# rel=noreferrer>retrying package</a></p><pre><code>from retrying import retry import requests def retry_if_connection_error(exception): """ Specify an exception you need. or just True""" #return True return isinstance(exception, ConnectionError) # if exception retry with 2 second wait @retry(retry_on_exception=retry_if_connection_error, wait_fixed=2000) def safe_request(url, **kwargs): return requests.get(url, **kwargs) response = safe_request('test.com') </code></pre><span class=d-none itemprop=commentCount>3</span><pre><code>from requests.adapters import HTTPAdapter from urllib3.util.retry import Retry MAX_RETRY = 2 MAX_RETRY_FOR_SESSION = 2 BACK_OFF_FACTOR = 0.3 TIME_BETWEEN_RETRIES = 1000 ERROR_CODES = (500, 502, 504) def requests_retry_session(retries=MAX_RETRY_FOR_SESSION, back_off_factor=BACK_OFF_FACTOR, status_force_list=ERROR_CODES, session=None): session = session retry = Retry(total=retries, read=retries, connect=retries, backoff_factor=back_off_factor, status_forcelist=status_force_list, method_whitelist=frozenset(['GET', 'POST'])) adapter = HTTPAdapter(max_retries=retry) session.mount('http://', adapter) session.mount('https://', adapter) return session class ConfigService: def __init__(self): self.session = requests_retry_session(session=requests.Session()) def call_to_api(): config_url = 'http://localhost:8080/predict/' headers = { "Content-Type": "application/json", "x-api-key": self.x_api_key } response = self.session.get(config_url, headers=headers) return response </code></pre><span class=d-none itemprop=commentCount>1</span><p>I was able to obtain the desired level of reliability by extending <code>requests.Session</code> class.</p><p>Here is the code <a href=# rel="nofollow noreferrer">https://bitbucket.org/bspeakmon/jira-python/src/a7fca855394402f58507ca4056de87ccdbd6a213/jira/resilientsession.py?at=master</a></p><p><strong>EDIT</strong> That code was:</p><pre><code>from requests import Session from requests.exceptions import ConnectionError import logging import time class ResilientSession(Session): """ This class is supposed to retry requests that do return temporary errors. At this moment it supports: 502, 503, 504 """ def __recoverable(self, error, url, request, counter=1): if hasattr(error,'status_code'): if error.status_code in [502, 503, 504]: error = "HTTP %s" % error.status_code else: return False DELAY = 10 * counter logging.warn("Got recoverable error [%s] from %s %s, retry #%s in %ss" % (error, request, url, counter, DELAY)) time.sleep(DELAY) return True def get(self, url, **kwargs): counter = 0 while True: counter += 1 try: r = super(ResilientSession, self).get(url, **kwargs) except ConnectionError as e: r = e.message if self.__recoverable(r, url, 'GET', counter): continue return r def post(self, url, **kwargs): counter = 0 while True: counter += 1 try: r = super(ResilientSession, self).post(url, **kwargs) except ConnectionError as e: r = e.message if self.__recoverable(r, url, 'POST', counter): continue return r def delete(self, url, **kwargs): counter = 0 while True: counter += 1 try: r = super(ResilientSession, self).delete(url, **kwargs) except ConnectionError as e: r = e.message if self.__recoverable(r, url, 'DELETE', counter): continue return r def put(self, url, **kwargs): counter = 0 while True: counter += 1 try: r = super(ResilientSession, self).put(url, **kwargs) except ConnectionError as e: r = e.message if self.__recoverable(r, url, 'PUT', counter): continue return r def head(self, url, **kwargs): counter = 0 while True: counter += 1 try: r = super(ResilientSession, self).head(url, **kwargs) except ConnectionError as e: r = e.message if self.__recoverable(r, url, 'HEAD', counter): continue return r def patch(self, url, **kwargs): counter = 0 while True: counter += 1 try: r = super(ResilientSession, self).patch(url, **kwargs) except ConnectionError as e: r = e.message if self.__recoverable(r, url, 'PATCH', counter): continue return r def options(self, url, **kwargs): counter = 0 while True: counter += 1 try: r = super(ResilientSession, self).options(url, **kwargs) except ConnectionError as e: r = e.message if self.__recoverable(r, url, 'OPTIONS', counter): continue return r </code></pre><span class=d-none itemprop=commentCount>4</span><p><strong>Method to retry certain logic if some exception has occured at time intervals t1=1 sec, t2=2 sec, t3=4 sec.</strong> We can increase/decrease the time interval as well.</p><pre><code>MAX_RETRY = 3 retries = 0 try: call_to_api() // some business logic goes here. except Exception as exception: retries += 1 if retries &lt;= MAX_RETRY: print("ERROR=Method failed. Retrying ... #%s", retries) time.sleep((1 &lt;&lt; retries) * 1) // retry happens after time as a exponent of 2 continue else: raise Exception(exception) </code></pre><span class=d-none itemprop=commentCount></span><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmirpJawrLvVnqmfpJ%2Bse6S7zGiorp2jqbawutJoaWxqZmyBcYWOoaawZaSkeqq5z6Wcpp2eqXqzsdOrsGallZi1orrIrKRmoZ6pvG682K2fqKZdp7KywcSsq6xlnJ6vs63Rsg%3D%3D</p><h4><i class="fas fa-share-alt" aria-hidden=true></i>&nbsp;Share!</h4><ul class=share-buttons><li><a href="https://www.facebook.com/sharer/sharer.php?u=%2fhow-to-implement-retry-mechanism-into-python-requests-library.html" target=_blank title="Share on Facebook"><i class="fab fa-facebook" aria-hidden=true></i><span class=sr-only>Share on Facebook</span></a></li>&nbsp;&nbsp;&nbsp;<li><a href="https://twitter.com/intent/tweet?source=%2fhow-to-implement-retry-mechanism-into-python-requests-library.html" target=_blank title=Tweet><i class="fab fa-twitter" aria-hidden=true></i><span class=sr-only>Tweet</span></a></li>&nbsp;&nbsp;&nbsp;<li><a href="https://plus.google.com/share?url=%2fhow-to-implement-retry-mechanism-into-python-requests-library.html" target=_blank title="Share on Google+"><i class="fab fa-google-plus" aria-hidden=true></i><span class=sr-only>Share on Google+</span></a></li>&nbsp;&nbsp;&nbsp;<li><a href="http://www.tumblr.com/share?v=3&u=%2fhow-to-implement-retry-mechanism-into-python-requests-library.html" target=_blank title="Post to Tumblr"><i class="fab fa-tumblr" aria-hidden=true></i><span class=sr-only>Post to Tumblr</span></a></li>&nbsp;&nbsp;&nbsp;<li><a href="http://pinterest.com/pin/create/button/?url=%2fhow-to-implement-retry-mechanism-into-python-requests-library.html" target=_blank title="Pin it"><i class="fab fa-pinterest-p" aria-hidden=true></i><span class=sr-only>Pin it</span></a></li>&nbsp;&nbsp;&nbsp;<li><a href="http://www.reddit.com/submit?url=%2fhow-to-implement-retry-mechanism-into-python-requests-library.html" target=_blank title="Submit to Reddit"><i class="fab fa-reddit-alien" aria-hidden=true></i><span class=sr-only>Submit to Reddit</span></a></li></ul><style>ul.share-buttons{list-style:none;padding:0}ul.share-buttons li{display:inline}ul.share-buttons .sr-only{position:absolute;clip:rect(1px 1px 1px 1px);clip:rect(1px,1px,1px,1px);padding:0;border:0;height:1px;width:1px;overflow:hidden}</style><div class="prev-next-post pure-g"><div class=pure-u-1-24 style=text-align:left><a href=./jayni-chase.html><i class="fa fa-chevron-left"></i></a></div><div class=pure-u-10-24><nav class=prev><a href=./jayni-chase.html>Jayni Chase</a></nav></div><div class=pure-u-2-24>&nbsp;</div><div class=pure-u-10-24><nav class=next><a href=./heartbreaking-deaths-of-these-old-hollywood-stars.html>Heartbreaking Deaths Of These Old Hollywood Stars</a></nav></div><div class=pure-u-1-24 style=text-align:right><a href=./heartbreaking-deaths-of-these-old-hollywood-stars.html><i class="fa fa-chevron-right"></i></a></div></div></div></div></div><script src=https://assets.cdnweb.info/hugo/blackburn/js/ui.js></script>
<script src=https://assets.cdnweb.info/hugo/blackburn/js/menus.js></script>
<script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://iklan.listspress.com/banner.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://iklan.listspress.com/tracking_server_1.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>